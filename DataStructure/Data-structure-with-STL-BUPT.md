# Data structure and STL (in C++)
# BUPT ver.(Xu Yajing, Xiao Bo)

---
> ## 目录
>  - [一、总述](#1)
>  - [二、线性表](#2)
>  - [三、栈、队列、串](#3)
>  - [四、多维数组 广义表](#4)
>  - [五、树](#5)
>  - [六、图](#6)
>  - [七、查找](#7)
>  - [八、排序](#8)

---
<h3 id="1">一、总述</h3>
1. 数据结构
分为逻辑结构（集合、线性结构、树或图）和存储结构（顺序、链式等）。
2. 算法及算法分析
算法准则：输入、输出、有穷性、确定性、可行性。
算法表述：自然语言、流程图、伪代码、程序设计语言。
算法分析：时间复杂度（基本语句、多项式时间算法、指数时间算法）、空间复杂度。

<h3 id="2">二、线性表</h3>
1. 数据元素、开始/终端结点、直接前驱/后继

> 线性表的运算：
> 求长度GetLenth(L)
> 遍历PrintList(L)
> 置空表SetNull(L)
> 按位查找Get(L,i)
> 按值查找Locate(L,x)
> 修改Set(L,i,x)
> 插入Inset(L,i,x)
> 删除Delete(L,i)
> 排序Sort(L)
2. 顺序表
顺序存储结构（连续按序存储），元素构造为类，数组存储元素，表长为私有变量。

> - 构造函数：
>   - 无参：设定表长为零；
>   - 有参：设定最大表长，修改数组元素，修改表长；
> - 遍历
> - 插入
>   - 异常：表满，上溢异常；位置不合理，插入异常；
>   - 先后移，再插入，修改表长；
> - 删除
>   - 异常：表空，下溢异常；位置不合理，删除异常；
>   - 先删除，再前移，修改表长；
> - 查找
>   - 按位：位置不合理，查找非法；
>   - 按值：基本算法为依次比较，匹配则返回；
 **静态存储、空间固定、访问方便、插/删效率低**
3. 链表
- 结点=数据+指针/链。
- 单链表：头指针、尾标志（null指针）、头结点、front指针、尾指针rear。
  - 私有front指针
>  - 构造：
>    * 无参：建立头结点，其链为null；
>    * 有参：
>      + 头插：建立新结点，修改其链，修改front链；
>      + 尾插：需要尾指针，建立新结点，修改尾结点链，修改尾指针；
>  - 析构：循环工作指针读front链、删除front结点、front读工作指针；
>  - 查找： _注意查找失败返回信息；_
>    * 按位：工作指针，计数器，循环后移，返回地址；
>    * 按值：工作指针，计数器，循环后移，返回位置或地址；
>  - 插入：
>    * 按位：先查找位置；
>    * 按元素：
>      + 后插：修改查找元素和插入元素的链；
>      + 前插：
>        * 找到前一元素，后插；
>        * **交换查找元素和插入元素的值转换为后插**；
>  - 删除：基本算法查找前继；
- 循环链表：单循环链表 尾指针，头结点，对头尾执行插删时方便；
- 双链表：prior+data+rear 存储效率低、定位操作方便；
- 动态链表：使用new/delete分配/回收结点空间；
- 静态链表：数组描述单链表：下标模拟指针，属于静态链表，空时为空闲链表，占用部分和空闲部分都建立链表方便使用。私有变量front/tail保存地址，结点为二维数组，分别保存数据域和指针域，指针域-1表示结束。
> - 构造：
>   * 无参：限制大小，设定front/tail，设定指针域；
>   * 有参：上溢异常，修改数据域、指针域，修改front/tail
> - 申请/释放空间：空间不足/释放非法异常；

<h3 id="3">三、栈、队列、串</h3>
1. 栈：仅限在表尾进行插删的线性表
  - 栈顶、栈底、空栈、栈的高度/长度、入/进栈、出/退栈、后进先出原则(LIFO)。
> - 置空栈SetNull(s)
> - 入栈Push(S,x)
> - 出栈Pop(S)
> - 取栈顶GetTop(S)
> - 判栈空Empty(S)

  - 顺序存储结构：数组实现，一维数组，私有栈顶指针，下标为0作栈底。  
                  两栈共享数组，分别以数组始末端作栈底，互相调节余缺、节省空间、减少上溢。
  - 链式存储结构（链栈）：结点结构数据域指针域，栈顶指针。
2. 队列：只允许队尾入队，队头出队，先进先出原则(FIFO)
> - 置空队SetNull(Q)
> - 入队EnQueue(Q,x)
> - 出队DeQueue(Q)
> - 取队头元素GetFront(Q)
> - 判队空Empty(Q)

- 循环队列：头尾相接的队列
  - front/rear，数组存储，设定数组长度；
  - 入队rear后移，出队front后移，涉及队内位置和队长时注意以数组长度取余(%)
- 链队列：头结点，数据域和指针域，front/rear指针。出队时若变为空队需要修改rear指针。
3. 串：字符串。结点元素仅由一个字符构成的线性表。
- 串名，串值，串长度，空串。子串，主串，子串在主串的位置(序号)。
> - 串的基本运算：
>   - 赋值 `=`
>   - 求串长度GetLength
>   - 串连接Strcat
>   - 求子串Substr
>   - 比较串大小Strcmp(对应位置字符编码的大小)
>   - 插入Insert
>   - 删除Delete
>   - 替换Replace
>   - 定位Index

- 串的存储结构
  - 顺序：
    * 类似顺序表，额外私有变量长度；
    * 使用特殊字符作结尾标记，不用存储长度。
  - 链式：
    * 结构与链表相同；
    * 可在每个结点存储多个字符以提高存储密度，增加空间利用率，结点中以特殊字符如"/0"表示结束，串以空指针表示结束。
- **串的模式匹配**
  - 在目标串S中查找与模式串T相同的子串并返回其位置，若查找失败则返回0。
  - 朴素模式匹配算法 **BF(Brute Force)**  
    将T的各个字符依次与S进行比较，若T全部字符都匹配则查找成功，否则回到S的下一字符重新开始比较，当S剩余字符长度不足以比较时查找失败。
  - **KMP(Knuth-Morris-Pratt)算法**
    * 前缀子串：从串第一个字符开始的，到倒数第二个字符或之前字符的子串；（不含最后一个字符的全部头部组合）
    * 后缀子串：从串第二个字符或之后字符开始的，到串最后一个字符的子串；（不含第一个字符的全部尾部组合）
    * 考虑模式串中出现重复字符时，已匹配的部分不用再匹配；
      + 匹配时：i、j都后移，继续匹配；
      + 不匹配时：构造next数组存储模式串回溯位置，当模式串中第j个字符不匹配时，回溯到模式串第next[j]个字符，next[0]不使用；
      >  * 特别的，`next[1]=0` 表示目标串与模式串位置i、j都后移，重新开始匹配；
      >  * `next[j]=1` j=2或j>2且不存在满足条件的前缀子串；
      >  * `next[j]=k+1` j>2且k为满足条件的前缀子串长度；
      >  * 条件是最大长度的相同前缀、后缀子串。

    * 递归求解next数组：
    > + next[1]=0; next[2]=1;
    > + j>=3 时
    >   若 next[j-1]=p，j字符不匹配，则串“t1 t2 --- tp-1”与串“tp-2 tp-3 --- tj-2”相同，只需比较 tp 与 tj-1 ；
    >   * tp = tj-1 时，next[j]=p+1 ;
    >   * tp != tj-1 时，next[j]=next[p] 。
  
    * 时间复杂度：计算next O(m) ，匹配 O(n)，整体O(m)+O(n)。

  - **BM(Boyer-Moore)算法**
    * 从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。
    * BM算法定义了两个规则：
      + 坏字符规则：匹配过程中，目标串中的失配字符为坏字符；  
                    此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置；  
                    使得目标串中的坏字符与模式串中的相同字符对齐，从其左继续匹配。
      + 好后缀规则：匹配的后缀子串称为好后缀；  
                    后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置；  
                    使得模式串中与好后缀相同的子串移到好后缀处。
  - **Sunday算法**
    * 从前往后匹配，在匹配失配时关注的是目标串中参加当次匹配的最末位字符的下一位字符；
      + 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；
      + 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1；
      + 使得下一位字符与模式串中相同字符对齐。
        
<h3 id="4">四、多维数组 广义表</h3>
1. 多维数组
- 行优先存储；
- 列优先存储；
- C++采用行优先，数组起始下标为0。
2. 矩阵的压缩存储
- 特殊矩阵压缩存储
  * 对称矩阵：关于主对角线对称，只存储上或下三角的元素；
  * 三角矩阵：上或下三角中元素为同一常数项，只存储另一三角及该常数项；
  * 对角矩阵：所有非零元素集中在对角线附件方阵中，去除零元素保留行不变构造新矩阵。
- 稀疏矩阵压缩存储
  * 非零元素个数远小于矩阵元素个数为稀疏；
  * 只存储非零元素；
    + 三元组表：将非零元素行、列、值构造成三元组，线性表顺序存储；
    + 十字链表：适应经常插删的操作，同一行和列的非零元素分别构造成一个带头结点的循环链表，非零元素行、列、值、同行下一非零元素、同列下一非零元素构造成五元组。
3. 广义表
- 逻辑结构
  * 表的结点为原子结点或广义表，递归定义；
  * 广义表的表头：第一个子表； 表尾：去除表头的的子表；
- 存储结构
  * 结点类型不确定，故使用链式，数据域存储数值（原子结点）或地址（广义表结点）。

<h3 id="5">五、树</h3>
1. 树：有限结点组成的具有层次关系的集合。
> - 子树：不含根结点；
> - 结点的度：结点含有的子树个数；
> - 树的度：最大的结点的度；
> - 根结点、叶结点（终端结点）
> - 分支结点
> - 双亲(父)结点、子结点
> - 兄弟结点
> - 祖先结点、子孙结点
> - 结点的层次：从根结点为第一层；
> - 树的高度/深度：最大的结点的层次；
> - 路径：根结点到某一结点的通道；
> - 路径长度：路径经过的边数；
> - 森林：互不相交的树的集合；
> - 有/无序树：子结点具有顺序与否。

- 树的存储结构
  - 需要存储结点信息和逻辑关系(父子)。
  - 双亲表示法
    * 一维数组，数据域和parent域(存储父结点的位置)，实际是静态链表；
    * 结构简单，查找父结点、祖先结点方便。
  - 孩子表示法
    * 一维数组加多个单链表，数组数据域和指针域(指向单链表)，单链表存储该结点的所有子结点；
    * 查找子结点、子孙结点方便。
  - 多重链表法
    * 数据域和多个指针域，每一指针指向一个子结点；
    * 容易浪费存储空间。
  - **孩子兄弟表示法(二叉链表表示法)**
    * 数据域和两个指针域，指向第一个子结点和第一个右兄弟；
    * 可转化树为二叉树。
- 树的遍历
  - 前序遍历：
    * 访问根结点；
    * 按从左向右顺序，前序遍历根结点的每一子树。
  - 后序遍历：
    * 按从左向右顺序，后序遍历根结点的每一子树；
    * 访问根结点。
  - 层序遍历(广度遍历)：
    * 从树的第一层开始向下逐层遍历，每一层按从左向右顺序逐个访问结点。
2. 二叉树
- 每个结点最多有两个子树的有序树。
- 满二叉树：叶结点都在最后一层，且其他结点度数均为2。
- 完全二叉树：去掉最后一层即成为满二叉树，且最后一层结点均靠左填满。
- 正则二叉树：结点度数为0或2。
- 二叉树的性质：
  * 非空二叉树第 `i (i>=1)` 层至多有 `2^(i-1)` 个结点；
  * 深度为 `h (h>1)` 的二叉树至多有 `2^h - 1` 个结点；
  * 二叉树叶结点数 `n0` 与度为2的结点数 `n2` 满足 `n0 = n2 + 1` ；
  * 具有 `n` 个结点的完全二叉树的深度为 `log2(n)下取整 + 1` ;
  * 对具有 `n` 个结点的完全二叉树，按从上到下、从左到右的顺序从1开始对结点编号，则对于序号为 `i` 的结点：
    + 双亲结点序号为 `i/2下取整` ；
    + 左孩子结点序号为 `2i (2i<=n)`，`2i>n `时没有左孩子(即该结点为叶结点)；
    + 右孩子结点序号为 `2i + 1 (2i+1 <= n)`，`2i+1 > n `时没有右孩子。
- 二叉树的存储
  * 顺序
    + 一维数组，层序遍历方式按完全二叉树编号，无结点的位置使用Null，顺序存储；
    + 适合完全二叉树存储，否则浪费空间。
  * 二叉链表
    + 数据域，左指针域/右指针域分别指向左/右孩子结点；
    + 孩子兄弟表示法，将任意树转化为二叉树。
  * 三叉链表
    + 双亲指针域，左指针域，数据域，右指针域；
    + 便于访问父结点。
- 二叉树的遍历
  * 前序遍历
    + 访问根结点；
    + 前序遍历访问左子树；
    + 前序遍历访问右子树。
  * 中序遍历
    + 中序遍历访问左子树；
    + 访问根结点；
    + 中序遍历访问右子树。
  * 后序遍历
    + 后序遍历访问左子树；
    + 后序遍历访问右子树。
    + 访问根结点；
  * 层序遍历
  * _前、中、后序遍历使用栈，层序使用队列。_
- 二叉树的实现
  * 创建：二叉链表，先建立根结点，层序遍历方式编号，序号为`i`的结点的子结点分别为`2i`和`2i+1`；
  * 遍历  
  _递归实现遍历原理清晰简单，但时间、空间效率不高，分析具体过程设定左/右子树遍历返回值可非递归实现遍历并加以优化。_
  * 析构：先释放子树，再释放根结点。
3. 树和森林
- 树/森林与二叉树一一对应，可转换如下：
  * 树转换成二叉树
    + 所有非长子都与父结点去掉关系，仅保留长子做左孩子；
    + 所有兄弟从左向右递归成为右孩子。
  * 森林转换成二叉树
    + 将每一棵树转换成二叉树；
    + 所有的树的根结点视为兄弟结点，递归成为右孩子。
  * 二叉树转换成树/森林
    + 右孩子都还原为兄弟结点，左孩子都是长子结点；
    + 第一层出现多个根结点，说明是森林，分开成多棵树。
- 森林的遍历
  * 前序遍历森林
    + 访问第一棵树的根结点；
    + 前序遍历第一棵树的根结点的子树；
    + 前序遍历其他树。
  * 后序遍历森林
    + 后序遍历第一棵树的根结点的子树；
    + 访问第一棵树的根结点；
    + 后序遍历其他树。
  * 前序遍历树/森林 = 前序遍历对应的二叉树；
  * 后序遍历树/森林 = 中序遍历对应的二叉树。
4. 哈夫曼树和编码
- 算法原理
  * 哈夫曼树又称最优二叉树，带权路径长度最短的二叉树。  
    _带权路径长度：所有的叶结点的权值乘其到根结点的路径长度的和。_`WPL = (W1*L1 + W2*L2 + ... + Wn*Ln)`
  * 哈夫曼编码根据字符的出现频率构造变长编码，使得平均码长最小。
  * 哈夫曼树的构造和编码：
    + 将所有带权值的结点作为仅由根结点构成的二叉树构造成集合；
    + 将其中根结点权值最小的两个依序作为左右子结点构造新二叉树，其根结点权值为子结点权值之和；
    + 在集合中用新二叉树替代原有的两个子二叉树；
    + 迭代上述两步，得到哈夫曼树；
    + 从根结点到叶结点，左孩子编码`0`，右孩子编码`1`，哈夫曼树的根结点不编码，各路径编码值分别为各叶结点的编码。
- 算法实现
  * 哈夫曼树：静态三叉链表存储，有`n`个叶结点则共有结点`2n+1`个；
  * 哈夫曼编码：
    + 创建编码表：采用叶结点回溯再将编码倒置的方法，存储编码字符串；
    + 编码：对照编码表；
    + 解码：(由于任一编码都不是另一编码的前缀)将码逐位读取，从根结点开始，`0`左`1`右，直至叶结点，解出一个字符，循环。

<h3 id="6">六、图</h3>
线性结构中的数据元素为一对一，树为一对多，图为多对多。
- 图的逻辑结构
  * 图由顶点集合和边集合构成，记为`G=(V,E)`，边集合`E`可以为空；
  * `(v1,v2)`表示无向边，`<v1,v2>`表示有向边顶点`v1`到`v2`；
  > * 顶点：数据元素；
  > * 边：无向边；
  > * 弧：有向边；
  > * 无向图：所有边都为无向边；
  > * 有向图：所有边都为有向边；
  > * 简单图：不存在顶点到自身的边或重复边；
  > * 邻接：无向边的顶点互为邻接点，有向边的终点为始点的邻接点；
  > * 完全无向图：对`n`个顶点有`n(n-1)/2`条边；
  > * 完全有向图：对`n`个顶点有`n(n-1)`条弧；
  > * 稀疏图/稠密图：边或弧的数量少/多；
  > * 顶点的度：与顶点相关联的边或弧的数目；
  > * 有向图顶点的入/出度：到达顶点/顶点出发的弧的数目；
  > * 网：带权值的图；
  > * 子图；
  > * 路径：顶点的序列；
  > * 路径长度：边/弧的数目；
  > * 回路：始点、终点相同；
  > * 简单路径：路径序列中顶点不重复的路径；
  > * 简单回路：除始点、终点外，路径序列中顶点不重复的路径；
  > * 连通图：任一对顶点间都存在路径的无向图；
  > * 连通分量：无向图的极大连通子图；
  > * 强连通图：任一对顶点间都存在路径的有向图；
  > * 强连通分量：有向图的极大连通子图；
  > * 生成树：连通图的极小连通子图；
  > * 生成森林：非连通图中各个连通分量的生成树构成。

- 图的存储结构
  * 邻接矩阵
    + 邻接矩阵元素`arc[i,j] = 1  (i != j)`表示存在边`i-j`或弧`i->j`(即存在邻接关系)，其他情况均有`arc[i,j] = 0`；
    + 特别地，网中：
      * `arc[i,j] = Wij  (i != j)`表示存在边`i-j`或弧`i->j`，且其权值为`Wij`；
      * `arc[i,j] = 0  (i == j)`表示与自身不存在邻接关系；
      * 其他则有`arc[i,j] = 无穷`(通常用比所有边权值大的数`MAX_VALUE`表示)。
    + 实现时，需要二维数组存储矩阵及顺序表存储顶点信息。
  * 邻接表
    + 对于每个顶点`vi`，将所有邻接于`vi`的顶点链接成一个单链表，即顶点`vi`的边表(有向图中的出边表)；
    + 所有的顶点用顺序表存储，即顶点表，存储顶点的信息和其对应的边表的头指针。
  * 十字链表
    + 用于有向图，结合邻接矩阵和邻接表；
    + 对每一顶点建立头结点，存储顶点信息、第一个以此顶点为弧头的弧结点的指针、第一个以此顶点为弧尾的弧结点的指针；
    + 对每一弧建立弧结点，存储弧头顶点、弧尾顶点、下一个以此顶点为弧头的弧结点的指针、下一个以此顶点为弧尾的弧结点的指针；
    + 所有头结点构成顺序表。
  * 邻接多重表
    + 用于无向图；
    + 相较邻接表，顶点表不变，边表中结点增加信息(两顶点的信息、两顶点的下一条边指针，共4个域)。
  * 边集数组
    + 两个一维数组，存储顶点和边；
    + 边信息包括始点、终点、权值。
  * 图的存储结构比较
    + 空间上：图越稠密越适合邻接矩阵，越稀疏越适合邻接表；
    + 时间上：邻接矩阵通常代价较高；
    + 邻接矩阵判定存在边或弧与否容易；
    + 邻接表求边的数目通常较简便；
    + 邻接多重表加强了对边的操作能力；
    + 边集数组适合稀疏图，依次操作边的情况。
- 图的遍历  
    图的遍历需要记录是否已遍历的布尔向量；
  * 深度优先遍历(Depth-First Search,DFS)
    + 从任一顶点`v`开始访问，标记`v`为已访问；
    + 访问`v`的第一未访问邻接顶点`w`，标记`w`为已访问；
    + 访问`w`的的第一未访问邻接顶点`u`，标记`u`为已访问；
    + ...
    + 当前顶点的邻接顶点访问完毕后，回溯到上一级顶点，访问其下一个邻接顶点；
    + 递归访问直至一个连通遍历结束；
    + 若为非连通图，则继续遍历下一连通分量。

  * 广度优先遍历(Breadth-First Search,BFS)
    + 访问顶点`v`，标记`v`为已访问；
    + 访问`v`的各个未访问链接结点`v1 v2 ... vn`并标记；
    + 分别访问`v1 v2 ... vn`的未访问邻接结点并标记；
    + 循环直至连通遍历结束；

  * DFS使用栈，BFS使用队列。
  * 遍历算法时间复杂度：邻接矩阵为`O(n^2)`，邻接表为`O(n+e) (e为边数)`。
- 最小生成树
  * 连通图的生成树：连通图中含所有结点的树状子图；
  * 最小生成树(Minimun Spanning Tree,MST)：连通网中各生成树的边权值之和最小的；
  * 普里姆(Prime)算法
    > + 选定一个结点作为MST的起始结点编为集合`U`，则其它顶点为集合`V-U`；
    > + 遍历`U`中顶点到`V-U`中顶点的边权值，选择最小的，对应顶点移动到`U`；
    > + 循环上一步直至`V-U`为空。

    + 时间复杂度`O(n^2)`。
  * 克鲁斯卡尔(Kruskal)算法
    > + 对所有边按权值排序；
    > + 选取权值最小的边，判断是否与之前选定的边构成回路，若没有则添加边；
    > + 循环上一步直至选取`n-1`条边。

    + 判断回路可通过标记所有顶点为各不相同，再逐条统一已选边的顶点的标记，当最小边的顶点标记与已选边不同时不会构成回路。
    + 时间复杂度`O(n^2)`，主要为排序时间。
- 最短路径
  * 最短路径的两个情况：
    + 顶点间有一条最小权值的边/弧；
    + 顶点`v0 vi`间相隔其他顶点`vx`，最短路径`v0-vi`包含的路径`v0-vx`是最短路径。
  * Dijkstra算法
    + 一个顶点到其他顶点的最短路径；
    + 按路径长度递增的次序产生始点到各顶点的最短路径。
    > + 从始点开始，记录到其它所有结点的路径长度；
    > + 选取其中最小权值的路径，将顶点加入最短路径，更新所有路径长度为目前最短路径顶点到其的路径长度；
    > + 循环上一步直至可能的顶点都已加入最短路径。

    + 时间复杂度`O(n^2)`。
  * Floyd算法
    + 任意两顶点间的最短路径。
    + 依次比较任意两顶点间的所有路径长度，选取最小的保留。
    + 使用邻接矩阵实现，初始化并记录路径信息(顶点序列)，即记录邻接顶点间路径长度；
    + 矩阵元素`e(i,j)`由`e(i,j) = e(i,p) + e(p,j)`，即计算非邻接顶点间路径长度，选取最小路径长度更新矩阵和路径信息；
    + 对`n`行矩阵`(1 <= p <= n)`，循环上一步。
    
    + 时间复杂度`O(n^3)`，主要为更新迭代矩阵。

<h3 id="7">七、查找</h3>
- 概述
  * 查找：在具有相同类型的数据集中找出满足给定条件的记录；
    + 关键码：用以标识一个记录的某个数据项；
    + 查找结果：在查找集中找到匹配的记录，则查找成功，一般需要返回记录的位置；
    + 静态查找：只查找和返回记录的位置；
    + 动态查找：查找并删除或查找并插入；
    + 查找结构：为了提高查找效率专门设置的数据结构；
      * 线性表：适用于静态查找，采用顺序查找技术、折半查找技术；
      * 树表：适用于动态查找，采用二叉排序树查找技术；
      * 散列表：静/动态查找均可，采用散列技术。

  * 查找算法的最基本操作：关键码和给定值的比较；
  * 平均查找长度(ASL)：查找表中每一记录的查找概率与对应记录的查找成功需要的比较次数的积的总和；查找失败的ASL为关键码的比较次数。
- 线性表查找
  * 顺序查找：依次比较每一记录的关键码和给定值；
    ```C++
    int search(int a[],int n,int key){
      for(int i = 0;i < n;i++){
        if(a[i] == key){
          return i + 1;
        }
      return 0;
      }
    }

    简化比较为：
    int search(int a[],int n,int key){
      a[0] = key;
      for(int i = n;a[i] != key;i--){
      }
      return i;
    }
    ```
    + 简单，适合查找少插删多的(采用链表)；
    + 查找效率低，不适合大表长的情况。
  * 折半查找(二分查找)
    + 需要待查找序列按关键码有序；
    + 将给定值与待查找序列的中间值比较，若小则在左区间继续查找，若大则在右区间继续查找，循环直至查找结束。
    + 比较少，速度快，平均性能好；
    + 需要有序，插删需要移动大量结点以保持表的有序性而不方便。
  * 分块查找(索引查找)
    + 基本表和索引表，基本表中的记录分块有序，即块有序而块内无序，索引表记录各个分块的最大关键码和起始地址；
    + 查找时先顺序查找或折半查找索引表，确定分块再对基本表中分块对应区间顺序查找；
    + 结合顺序查找和分块查找，插删容易；
    + 需要额外的索引表空间和初始化表时的分块排序运算。
- 树表查找
  * 二叉排序树(Binary Sort Tree,BST)
    + 二叉排序树为空树或具有如下特征：
      * 左子树为空，或左子树所有结点小于根结点；
      * 右子树为空，或右子树所有结点大于根结点；
      * 子树均为二叉排序树。
    + 中序遍历该树得到递增有序序列；
    + 二叉排序树的初始化即依次插入各结点；
    + 查找从根结点出发，若小则左子树，大则右子树，直至查找结束；
    + 删除结点时：
      * 无子树结点：直接删除；
      * 单子树结点：删除并将子树连接；
      * 双子树结点：用其直接前驱或后继替代该结点，并删除该前驱或后继(递归)。
    + 插删容易，性能好，接近折半查找。
  * 平衡二叉树
    + 平衡二叉树为空树或具有如下特征：
      * 左、右子树高度差不超过１；
      * 子树均为平衡二叉树。
    + 对于每一个结点的插入，根据其插入位置分四种情况采用动态平衡，保持平衡二叉树；
      > * LL：根结点的左孩子的左子树；
      > * LR：根结点的左孩子的右子树；
      > * RL：根结点的右孩子的左子树；
      > * RR：根结点的右孩子的右子树；
    + 查找速度快，性能约等同折半查找；
    + 插删需要动态平衡，很不方便。
- 散列表查找
  * 散列技术：在存储元素与关键码之间建立确定对应关系`H`(散列函数)，使得每一关键码`key`对应唯一存储位置`H(key)`(散列值)；
  * 通过散列技术存储得到散列表，查找时计算给定值的`H(key)`即可找到散列地址访问元素；
  * 面向查找，不能表示元素间的逻辑关系；
  * 散列函数设计：
    + 直接定址法：
      * `H(key) = a * key + b  (a、ｂ为常数)`
      * 散列函数为关键码的线性函数，适合关键码分布比较连续时；
    + 除留余数法：
      * `H(key) = key % p`
      * 通常选取`p`为不大于散列长度`m`的素数（或不含２０以内的质因数的合数），注意避免冲突；
      * 计算散列地址简单，适用范围广。
    + 数字分析法
      * 关键码均为相同位数，其中若干位分布均匀，提取作为地址；
      * 适合对关键码取值有所分析的场景。
    + 平方取中法
      * 将关键码平方后取中间若干位作为地址；
      * 平方可扩大差别，中间位可受整个关键码各位的影响；
      * 适用于关键码不清楚且位数不太多。
    + 折叠法
      * 将关键码分为若干位数相同的部分，将各部分折叠后取和作为地址；
        + 移位叠加：将各部分末位对齐相加；
        + 间界相加：将各部分按分界来回折叠后，末位对齐相加；
      * 适合关键码位数很多的情况。
  * 冲突处理
    + 散列函数选取不够优秀，导致不同关键字计算得到相同地址时的处理；
    + 开放定址法
      * 产生冲突时，在散列表中生成一个探测序列，按探测序列逐个单元查找，直至找到对应的关键码或遇到开放地址；
      * 插入时，开放地址可存储新结点；查找时，开放地址意味着查找失败；
      * 探测方法：
        + 线性探测法：冲突处地址`Hi = (H(key) + di) % m  (di = 1,2, ... ,m-1　i为冲突次数)`
        + 平方探测法：`Hi = (H(key) + di) % m  (di = 1^2,-1^2,2^2,-2^2, ...  i为冲突次数)`
        + 随机探测法：`Hi = (H(key) + di) % m  (di为伪随机序列)`
      * 可能产生不同散列地址的元素争夺同一后继散列地址，即堆积；
      * 由于空格的特殊意义和冲突处理导致的散列地址后移，删除结点只能标记结点为删除状态，而不能真正删除。
    + 链地址法
      * 每一散列地址用一单链表存储各关键码，称为同义词子表；
      * 散列表存储各个单链表的头指针；
      * 平均查找长度较短，动态的结点空间，易于构造和删除。
    + 建立公共溢出区法
      * 分为基本表和溢出表，冲突的记录顺序存储在溢出表；
      * 查找时先按散列地址在基本表查找，未成功则到溢出表顺序查找。
  * 算法性能
    + 冲突很大程度影响性能；
    + 散列函数是否均匀、冲突处理是否得当、散列表使用比例等都影响冲突。
- 查找应用
  * 布隆过滤器(Bloom Filter)
    + 由一很长的二进制的位向量和一系列随机映射函数(Hash函数)构成；
    + 用于检索一个元素是否在某集合中；
    + 位向量初始化值为全`0`，存储元素时，映射元素到位向量的某些位，修改其值为`1`；
    + 查找时，计算给定值的映射位，若其全为`1`，则判定元素存在；
    + 不会漏报(False Negative)，会误报(False Positive)；
    + 存储空间固定，插入/查找时间固定，Hash函数可用硬件并行实现，不需存储元素本身利于保密；
    + 删除困难(每一位都可能含有其它元素的信息，不可随意更改，且存在误报，不能简单地改为计数器减一表示删除)。
  * 中文分词技术的词搜索算法
    + 中文分词(Chinese Word Segmentation)是将中文序列切分为单独的词，实现文本转换为词向量，便于抽取特征实现文本自动分析处理；
    + 基于字符串的分词方法：按一定策略将待分析的汉字串与一个“充分大的”中文词典中的词条进行匹配。
    + 使用散列技术，利用中文字字符的编码特点，尽量达到无冲突，空间需求只有数十M，平均查找长度不大。
<h3 id="8">八、排序</h3>
- 概述
  * 排序：给定一个元素序列，按各元素关键码重新排列，使得关键码正序(从小到大)或逆序；
  * 趟：排序算法中，遍历待排序元素；
  * 稳定性：相同关键码的元素排序后相对次序稳定不变；
  * 顺序表具有随机存取特性，存取时间复杂度为`O(1)`，链表为`O(n)`，排序算法基本都基于顺序表；
  * 排序有非递增排序和非递减排序；
  * 排序算法性能主要考虑关键码比较和元素移动次数。
- 插入排序
  * 基本思想是寻找指定元素在待排序元素序列中的位置并插入；
  * 直接插入排序：
    + 从单元素顺序表开始，逐个元素用顺序查找方法查找位置并插入；
    + 时间复杂度`O(n^2)`，空间复杂度`O(1)`；
    + 稳定。
  * 希尔排序：
    + 基本思想：将待排序元素集分为多个子集，分别直接插入排序，使得整个序列基本有序，再进行一次直接插入排序；
    + 分集的方法为按增量取元素，一次分集排序结束后减小增量，循环直至增量为`1`，即排序完成；
    + 增量通常取`d = n / 2, d(i+1) = d(i) / 2`；
    + 时间复杂度`O(n^2) 到 n*log2(n)`；空间复杂度`O(1)`；
    + 不稳定。
- 交换排序
  * 基本方法：在待排序元素中选择两个元素，比较其关键码，如果反序则交换位置，直至没有反序记录；
  * 冒泡排序：
    + 基本思想：比较两两相邻元素；
    + 从前向后依次比较相邻两元素，反序则交换，每一趟至少使得序列尾部增加一个有序元素，构成有序区(相对序列前端的无序区)；
    + 改进：记录一趟的最后一次交换所在位置，则其后为有序区，下一趟不必再比较其中的元素；
    + 平均时间复杂度`O(n^2)`，空间复杂度`O(1)`；
    + 稳定。
  * 快速排序：
    + 基本思想：在分区中选定一个元素作为轴值，使得左侧元素均小于或等于轴值，右侧元素均大于或等于轴值，在左/右分区循环，直至分区只有一个元素，排序结束；
    + 具体实现：
      * 轴值可任选，保存在任意位置，标记分区左右界为`i 和 j`；
      * 右侧扫描，从后向前，找到第一个小于轴值的元素，移至位置`i`；
      * 左侧扫描，找到第一个大于轴值的元素，移至位置`j`；
      * 循环上两步直至`i == j`，轴值元素移至位置`i`，一趟结束；
      * 当分区元素为`1`时排序结束。
    + 时间复杂度`O(n*log2(n))`，空间复杂度`O(log2(n))`；
    + 不稳定。
- 选择排序
  * 基本方法：每趟在待排序序列中选择关键码最小的元素，顺序添加到已排好序的有序序列的最后，直到全部记录排序完毕；
  * 简单选择排序：
    + 第`i`趟将待排序序列`r[i, ... ,n]`中选择关键码最小的记录，与`r[i]`交换，循环；
    + 时间复杂度`O(n^2)`，空间复杂度`O(1)`；
    + 不稳定。
  * 堆排序：
    + 堆：具有一定性质的完全二叉树；
      * 小根堆：每一结点的值不大于其子结点的值；
      * 大根堆：每一结点的值不小于其子结点的值；
    + 建堆：
      * 关键是完全二叉树调整根结点以满足堆条件(称为筛选)：
        + 大根堆：比较根结点与左右孩子，若不满足堆的条件，则交换较大孩子与根结点，循环；
        + 小根堆类似；
      * 建堆时，从最后一个结点沿二叉树逐层逐个向上筛选，直至根结点；
      * 堆存储：数组`r[n]`成队列，根结点`r[1]`，左孩子`r[2i]`，右孩子`r[2i+1]`，父结点`r[i/2]`。
    + 排序实现：
      * 将待排序元素构造成堆；
      * 输出堆顶元素，将堆最后一个元素移至堆顶，调整元素成堆，循环；
      * 节省空间可输出元素与堆最后一个元素交换，堆元素队列队尾减`1`。
    + 时间复杂度`O(n*log2(n))`；
    + 不稳定。
- 归并排序
  * 基本方法：将两个或以上的有序序列归并成一个；
  * 二路归并排序：
    + 将`n`个元素的待排序序列分为`n`个子序列；
    + 相邻两子序列合并，得到`n/2`个子序列，一趟结束；
    + 循环直至排序结束。
    + 分序列方法：递归，从分为`2`个子序列到分为`2i`个子序列；
    + 合并方法：
      * 逐一比较两子序列的元素，把较小的元素放入缓冲区，取其所在序列下一元素进行比较，循环直至某一序列为空；
      * 将另一序列剩余元素添加至缓冲区尾部。
    + 时间复杂度`O(n*log2(n))`，空间复杂度`O(n)`；
    + 稳定。
- 排序的比较
  * 快速排序时间性能最好；
  * 待排序元素较多时，归并排序较堆排序更快；
  * 直接插入排序、冒泡排序、归并排序稳定；
  * 选取排序方法参考：
    + 元素少：直接插入排序，简单选择排序(元素本身信息量较大时)；
    + 元素初始状态按关键码基本有序：直接插入排序，冒泡排序；
    + 元素多：快速排序(按关键码随机分布)，堆排序(坏情况性能好，辅助空间少)，归并排序(稳定)。
- 外部排序
  * 内存不足以存储全部待排序元素；
  * 方法：
    + 将待排序序列分为若干段，逐段写入内存进行内部排序得到结果(顺串)，顺串写入外存；
    + 将各顺串归并成一个顺串。
  * 时间复杂度主要取决于内外存数据交换。
- 排序应用
  * 电话号码排序
    + 数据元素等长，值不重复，数据量很大；
    + 散列函数，位图：
      * 构造空散列表，位串；
      * 读取文件，对每一数据，在数据对应的位串位置置`1`，并调用函数，生成散列表对应项；
      * 读取散列表，将位串中bit位为`1`的地址按顺序读出写入文件，完成排序。
